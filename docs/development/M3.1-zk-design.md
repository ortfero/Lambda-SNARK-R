# M3.1: Zero-Knowledge Design Specification

**Date**: November 7, 2025  
**Milestone**: M3 (Zero-Knowledge)  
**Status**: üîß IN PROGRESS  
**Dependencies**: M2.2 ‚úÖ, M2.3 ‚úÖ, LWE FFI ‚úÖ

---

## Executive Summary

This specification defines the Zero-Knowledge (ZK) extension for ŒõSNARK-R prover. The goal is to achieve **honest-verifier zero-knowledge (HVZK)** by adding polynomial blinding to commitments and openings, ensuring that proofs reveal nothing about the witness beyond the statement's validity.

**Approach**: Polynomial blinding with random masking polynomial r(X)

**Key Properties**:
- ‚úÖ Zero-Knowledge: Simulator indistinguishable from real prover
- ‚úÖ Soundness preserved: Œµ ‚â§ 2^-44 (unchanged)
- ‚úÖ Completeness preserved: Valid proofs verify (100%)
- ‚úÖ Non-interactive: Via Fiat-Shamir transform (already implemented)

---

## Current System (Non-ZK)

**Prover Algorithm**:
```
1. Encode witness: f(X) = Œ£ z_i¬∑X^i
2. Commit: C = Commit(f(X), seed)
3. Challenge: Œ± = H(public_inputs || C)
4. Opening: y = f(Œ±)
5. Proof: œÄ = (C, Œ±, y, witness)
```

**Problem**: Opening reveals `y = f(Œ±)`, which may leak information about witness `z`.

**Example Leakage**:
- Witness: z = [z‚ÇÄ, z‚ÇÅ, ..., z‚Çô]
- Evaluation: y = f(Œ±) = z‚ÇÄ + z‚ÇÅ¬∑Œ± + z‚ÇÇ¬∑Œ±¬≤ + ... + z‚Çô¬∑Œ±‚Åø
- If public inputs constrain some z_i, then y reveals linear combination

---

## Zero-Knowledge Extension

### Polynomial Blinding Scheme

**Idea**: Add random polynomial r(X) to hide f(X)

**Blinding Polynomial**:
```
r(X) = r‚ÇÄ + r‚ÇÅ¬∑X + r‚ÇÇ¬∑X¬≤ + ... + r_d¬∑X^d
where r_i ‚Üê U(F_q) (uniform random from field)
      d = deg(f) (same degree as witness polynomial)
```

**Blinded Polynomial**:
```
f'(X) = f(X) + r(X)
```

**Commitment** (modified):
```
C = Commit(f'(X), seed) = Commit(f(X) + r(X), seed)
```

**Opening** (modified):
```
y' = f'(Œ±) = f(Œ±) + r(Œ±)
```

**Verification** (modified):
```
Check: y' = (f + r)(Œ±)
     = f(Œ±) + r(Œ±)
```

### Prover Algorithm (ZK Version)

**Input**:
- Witness: z = [z‚ÇÄ, z‚ÇÅ, ..., z‚Çô]
- Public inputs: pub
- LWE context: ctx
- Modulus: q
- Commitment seed: seed
- **Blinding seed: blinding_seed** (NEW)

**Algorithm**:
```
1. Encode witness polynomial:
   f(X) = Œ£ z_i¬∑X^i

2. Generate blinding polynomial:
   r(X) = random_polynomial(degree=n, modulus=q, seed=blinding_seed)
   
3. Compute blinded polynomial:
   f'(X) = f(X) + r(X)  (mod q)
   
4. Commit to blinded polynomial:
   C = Commit(f'(X), seed)
   
5. Derive Fiat-Shamir challenge:
   Œ± = H(public_inputs || C)  (mod q)
   
6. Compute blinded evaluation:
   y' = f'(Œ±) = f(Œ±) + r(Œ±)  (mod q)
   
7. Generate opening proof:
   opening = Opening(y', witness=[seed, f'‚ÇÄ, f'‚ÇÅ, ..., f'‚Çô])
   
8. Return proof:
   œÄ = (C, Œ±, y', opening)
```

### Verifier Algorithm (ZK Version)

**Input**:
- Proof: œÄ = (C, Œ±, y', opening)
- Public inputs: pub
- Modulus: q
- LWE context: ctx (for LWE verification)

**Algorithm**:
```
1. Recompute Fiat-Shamir challenge:
   Œ±' = H(public_inputs || C)
   
2. Check challenge consistency:
   if Œ±' ‚â† Œ±: return REJECT
   
3. Reconstruct blinded polynomial from opening:
   f'(X) = opening.witness[1] + opening.witness[2]¬∑X + ...
   
4. Verify blinded evaluation:
   if y' ‚â† f'(Œ±): return REJECT
   
5. Verify LWE commitment binding:
   if !lwe_verify_opening(C, f', opening): return REJECT
   
6. Return ACCEPT
```

**Note**: Verifier does NOT need to know r(X) or f(X). Only checks f'(X) consistency.

---

## Zero-Knowledge Property

### Simulator Algorithm

**Goal**: Construct proof without witness that is indistinguishable from real proof.

**Simulator Input**:
- Public inputs: pub
- Modulus: q
- LWE context: ctx

**Simulator Algorithm**:
```
1. Sample random blinded polynomial:
   f'(X) = random_polynomial(degree=n, modulus=q)
   
2. Commit to random polynomial:
   C = Commit(f'(X), random_seed)
   
3. Derive challenge (same as prover):
   Œ± = H(public_inputs || C)
   
4. Evaluate at challenge:
   y' = f'(Œ±)
   
5. Generate opening:
   opening = Opening(y', witness=[random_seed, f'‚ÇÄ, ..., f'‚Çô])
   
6. Return simulated proof:
   œÄ_sim = (C, Œ±, y', opening)
```

### Indistinguishability Argument

**Theorem** (Informal): Real proofs and simulated proofs are computationally indistinguishable under LWE assumption.

**Proof Sketch**:

**Real Proof Distribution**:
```
œÄ_real ~ (Commit(f(X) + r(X)), Œ±, f(Œ±) + r(Œ±), opening)
where r(X) ‚Üê U(F_q^{n+1})
```

**Simulated Proof Distribution**:
```
œÄ_sim ~ (Commit(f'(X)), Œ±, f'(Œ±), opening)
where f'(X) ‚Üê U(F_q^{n+1})
```

**Key Observation**:
- f(X) + r(X) is distributed uniformly over F_q^{n+1} (since r is uniform)
- f'(X) is distributed uniformly over F_q^{n+1} (by construction)
- Therefore: f(X) + r(X) ‚â° f'(X) (distribution equivalence)

**Distinguisher Advantage**:
```
Adv_ZK(A) = |Pr[A(œÄ_real) = 1] - Pr[A(œÄ_sim) = 1]|
           ‚â§ Adv_LWE(B) + negl(Œª)
           ‚âà 2^-128 (for Œª=128)
```

**Assumptions**:
1. **LWE hardness**: Commitment hiding holds
2. **Random oracle**: H modeled as random oracle
3. **Uniform blinding**: r(X) sampled uniformly

---

## Security Analysis

### Soundness Preservation

**Claim**: ZK extension does NOT weaken soundness.

**Argument**:
- Verifier checks f'(Œ±) = y' (blinded polynomial evaluation)
- LWE commitment binding ensures f'(X) is fixed
- Prover cannot change f'(X) after commitment
- Soundness error unchanged: Œµ ‚â§ 2^-44

**Attack Attempt**:
- Malicious prover tries to prove invalid statement
- Must provide f'(X) such that f'(Œ±) = y' for random Œ±
- Probability of success ‚â§ 1/q ‚âà 2^-44 (polynomial degree bound)

### Completeness Preservation

**Claim**: Valid witnesses always produce accepting proofs.

**Verification**:
1. Honest prover: f'(X) = f(X) + r(X)
2. Commitment: C = Commit(f'(X))
3. Opening: y' = f'(Œ±)
4. Verification: f'(Œ±) = f(Œ±) + r(Œ±) = y' ‚úÖ

**Completeness**: 100% (deterministic for honest prover)

### Witness Hiding

**Property**: Proof reveals nothing about witness z beyond public inputs.

**Information Leakage Analysis**:

**Public Information** (in proof):
- Commitment C: LWE ciphertext (hiding under LWE)
- Challenge Œ±: deterministic from C (no info)
- Evaluation y': blinded by r(Œ±) (uniformly random)
- Opening witness: includes f'(X) = f(X) + r(X) (uniformly random)

**Leaked Information**:
- None beyond what's derivable from public inputs

**Mutual Information**:
```
I(z ; œÄ | public_inputs) ‚â§ negl(Œª)
```

---

## Implementation Details

### Randomness Generation

**CSPRNG Requirements**:
- Use `rand::thread_rng()` from Rust `rand` crate
- Cryptographically secure (ChaCha20-based)
- Thread-local seeding from OS entropy

**Blinding Polynomial Generation**:
```rust
pub fn random_polynomial(degree: usize, modulus: u64, seed: Option<u64>) -> Polynomial {
    let mut rng = if let Some(s) = seed {
        ChaCha20Rng::seed_from_u64(s)
    } else {
        ChaCha20Rng::from_entropy()
    };
    
    let coeffs: Vec<Field> = (0..=degree)
        .map(|_| Field::new(rng.gen::<u64>() % modulus))
        .collect();
    
    Polynomial::new(coeffs, modulus)
}
```

### Polynomial Addition

**Field Operations** (constant-time via shared helpers; snippet assumes `use crate::arith::add_mod;`):
```rust
impl Polynomial {
   pub fn add(&self, other: &Polynomial) -> Polynomial {
      assert_eq!(self.modulus, other.modulus);

      let max_len = self.coeffs.len().max(other.coeffs.len());
      let mut result = Vec::with_capacity(max_len);

      for i in 0..max_len {
         let a = self.coeffs.get(i).map(|f| f.value()).unwrap_or(0);
         let b = other.coeffs.get(i).map(|f| f.value()).unwrap_or(0);
         result.push(Field::new(add_mod(a, b, self.modulus)));
      }

      Polynomial::new(result, self.modulus)
   }
}
```

### API Changes

**New Function**:
```rust
pub fn prove_zk(
    witness: &[u64],
    public_inputs: &[u64],
    ctx: &LweContext,
    modulus: u64,
    commit_seed: u64,
    blinding_seed: Option<u64>, // None = random
) -> Result<Proof, Error>;
```

**Backward Compatibility**:
```rust
pub fn prove_simple(...) -> Result<Proof, Error> {
    // Non-ZK version (for backward compat)
    prove_zk(..., blinding_seed = Some(0)) // No blinding
}
```

---

## Performance Analysis

### Computational Overhead

**Blinding Generation**: O(n)
- Sample n+1 random field elements
- Time: ~1Œºs for n=4

**Polynomial Addition**: O(n)
- Add corresponding coefficients
- Time: ~0.1Œºs for n=4

**Total Overhead**: ~1.1Œºs
- Negligible compared to commitment (25ms)
- Expected slowdown: <1%

### Proof Size

**Additional Data**: None
- Blinding polynomial r(X) NOT included in proof
- Proof contains f'(X) = f(X) + r(X) (same size as before)
- Size: 64KB (unchanged)

### Memory Overhead

**Temporary Storage**:
- Blinding polynomial r(X): (n+1)√ó8 bytes ‚âà 40 bytes for n=4
- Blinded polynomial f'(X): (n+1)√ó8 bytes ‚âà 40 bytes
- Total: ~80 bytes (negligible)

---

## Test Plan

### Unit Tests

1. **Random Polynomial Generation**
   - Uniformity: Chi-squared test for coefficient distribution
   - Independence: Correlation test between coefficients
   - Determinism: Same seed ‚Üí same polynomial

2. **Polynomial Addition**
   - Correctness: (f + r)(Œ±) = f(Œ±) + r(Œ±)
   - Commutativity: f + r = r + f
   - Modular reduction: all coefficients < q

3. **Blinded Commitment**
   - Different blindings ‚Üí different commitments
   - Hiding: commitment hides witness polynomial

### Integration Tests

4. **ZK Proof Generation**
   - Valid witness ‚Üí valid ZK proof
   - Different blindings ‚Üí different proofs (same witness)
   - Deterministic blinding ‚Üí deterministic proof

5. **ZK Proof Verification**
   - Valid ZK proof ‚Üí accepts
   - Invalid evaluation ‚Üí rejects
   - Soundness: forged proof ‚Üí rejects

6. **Simulator Tests**
   - Simulator produces valid-looking proofs
   - Distinguisher advantage ‚â§ negligible (statistical test)

### Security Tests

7. **Witness Hiding**
   - Extract witness from proof ‚Üí fails (brute-force)
   - Information leakage: I(z ; œÄ) ‚âà 0 (empirical)

8. **Soundness Preservation**
   - Invalid witness ‚Üí proof rejects (with/without ZK)

9. **Completeness**
   - All valid witnesses ‚Üí proofs verify (100% rate)

---

## Limitations and Future Work

### Current Limitations

1. **Honest-Verifier ZK**: Not full ZK (requires trusted challenge)
2. **Non-Malleability**: Not addressed (future work)
3. **Knowledge Extraction**: No explicit extractor (ZK of knowledge)

### Future Enhancements

1. **Full Zero-Knowledge**
   - Interactive version with verifier randomness
   - Or: simulation-sound extractability

2. **Batch Blinding**
   - Amortize blinding cost over multiple proofs
   - Share random tape across proofs

3. **Optimized Randomness**
   - Use PRG to expand short seed ‚Üí long blinding
   - Reduce entropy requirements

---

## Conclusion

The polynomial blinding scheme provides honest-verifier zero-knowledge with minimal overhead:

- ‚úÖ **Zero-Knowledge**: Simulator indistinguishable (Adv ‚â§ 2^-128)
- ‚úÖ **Soundness**: Preserved (Œµ ‚â§ 2^-44)
- ‚úÖ **Completeness**: Preserved (100%)
- ‚úÖ **Performance**: <1% overhead
- ‚úÖ **Simplicity**: Minimal API changes

**Next Steps**: Implement M3.2 (Blinding Polynomial Generation)

---

**Document Version**: 1.0  
**Last Updated**: November 7, 2025  
**Author**: URPKS Development Team  
**Review Status**: Ready for implementation
