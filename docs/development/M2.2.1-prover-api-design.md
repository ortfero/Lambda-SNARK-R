# M2.2.1: Prover API Design Specification

**Ğ”Ğ°Ñ‚Ğ°**: 7 Ğ½Ğ¾ÑĞ±Ñ€Ñ 2025  
**Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ**: ğŸ”„ IN PROGRESS  
**Ğ¦ĞµĞ»ÑŒ**: Ğ¡Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸ Ğ·Ğ°Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ¿Ñ€ÑƒĞ²ĞµÑ€Ğ° Ğ´Ğ»Ñ Î›SNARK-R

---

## High-Level Interface

### Core Functions

```rust
/// Setup: generate proving and verifying keys from R1CS
pub fn setup(params: Params, r1cs: R1CS) -> Result<(ProvingKey, VerifyingKey), Error>

/// Prove: generate SNARK proof for witness
pub fn prove(pk: &ProvingKey, witness: &[u64], public_inputs: &[u64]) 
    -> Result<Proof, Error>

/// Verify: check proof validity
pub fn verify(vk: &VerifyingKey, public_inputs: &[u64], proof: &Proof) 
    -> Result<bool, Error>
```

---

## Data Structures

### ProvingKey

```rust
pub struct ProvingKey {
    /// LWE context (secret key, parameters)
    ctx: LweContext,
    
    /// R1CS constraint system
    r1cs: R1CS,
    
    /// Polynomial encoding parameters
    encoding: PolynomialEncoding,
    
    /// Number of public inputs
    num_public: usize,
}
```

**Invariants**:
- `num_public â‰¤ r1cs.num_variables()`
- `ctx.params()` validated (q prime, n power-of-2)

---

### VerifyingKey

```rust
pub struct VerifyingKey {
    /// Public parameters
    params: Params,
    
    /// R1CS constraint system (public)
    r1cs: R1CS,
    
    /// Polynomial encoding parameters
    encoding: PolynomialEncoding,
    
    /// Number of public inputs
    num_public: usize,
}
```

**Note**: VerifyingKey Ğ½Ğµ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ secret key â€” Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ¾Ğ²Ğ°Ğ½.

---

### Proof

```rust
pub struct Proof {
    /// LWE commitment to witness polynomial
    commitment: Commitment,
    
    /// Fiat-Shamir challenge
    challenge: Challenge,
    
    /// Opening proof at challenge point Î±
    opening: Opening,
}

pub struct Commitment {
    /// LWE ciphertext: c = AÂ·s + e + m
    ciphertext: Vec<u64>,
}

pub struct Challenge {
    /// Challenge point Î± âˆˆ F_q
    alpha: Field,
    
    /// SHA3-256 hash used for derivation
    hash: [u8; 32],
}

pub struct Opening {
    /// Evaluation f(Î±)
    evaluation: Field,
    
    /// Witness for evaluation (LWE opening)
    witness: Vec<u64>,
}
```

---

## Prover Algorithm (High-Level)

### Input
- `pk: &ProvingKey` â€” proving key
- `witness: &[u64]` â€” full witness vector `z = [1, inputs..., outputs..., internals...]`
- `public_inputs: &[u64]` â€” public portion `z[0..num_public]`

### Output
- `Proof` â€” succinct proof of knowledge

### Steps

```
1. VALIDATE WITNESS
   - Check: len(witness) = r1cs.num_variables()
   - Check: witness[0] = 1 (constant convention)
   - Check: witness[0..num_public] = public_inputs
   - Check: r1cs.validate_witness(witness) âœ“

2. POLYNOMIAL ENCODING
   - Encode witness as polynomial: f(X) = Î£ witness[i] Â· X^i
   - Degree: deg(f) = len(witness) - 1

3. COMMITMENT
   - Sample randomness: r â† {0,1}^Î»
   - Compute LWE commitment: com = Commit(pk.ctx, f, r)
   - Output: commitment = com

4. FIAT-SHAMIR CHALLENGE
   - Construct transcript: Ï„ = public_inputs || commitment
   - Hash: h = SHA3-256(Ï„)
   - Derive challenge: Î± = h mod q

5. EVALUATION
   - Compute: y = f(Î±) mod q
   - Compute: Az(Î±), Bz(Î±), Cz(Î±) for constraint check

6. OPENING PROOF
   - Generate opening: Ï€ = Open(pk.ctx, f, Î±, r)
   - Output: opening = (y, Ï€)

7. ASSEMBLE PROOF
   - proof = Proof { commitment, challenge, opening }
   - Return proof
```

---

## Polynomial Encoding

### Witness â†’ Polynomial

**Input**: `witness = [z_0, z_1, ..., z_{n-1}]`  
**Output**: `f(X) = Î£_{i=0}^{n-1} z_i Â· X^i`

**Properties**:
- Degree: `deg(f) = n - 1`
- Evaluation: `f(Î±) = Î£ z_i Â· Î±^i mod q`
- Binding: Different witnesses â†’ different polynomials (with high probability)

**Example** (TV-1: `witness = [1, 7, 13, 91]`):
```
f(X) = 1 + 7X + 13XÂ² + 91XÂ³
```

---

## Fiat-Shamir Transform

### Challenge Derivation

**Input**: 
- `public_inputs: &[u64]`
- `commitment: &Commitment`

**Output**: 
- `challenge: Challenge { alpha, hash }`

**Algorithm**:
```rust
fn derive_challenge(public_inputs: &[u64], commitment: &Commitment) -> Challenge {
    // 1. Construct transcript
    let mut hasher = Sha3_256::new();
    hasher.update(b"LAMBDA-SNARK-R-FS-v1");
    hasher.update(&public_inputs.len().to_le_bytes());
    for inp in public_inputs {
        hasher.update(&inp.to_le_bytes());
    }
    hasher.update(&commitment.ciphertext);
    
    // 2. Hash
    let hash: [u8; 32] = hasher.finalize().into();
    
    // 3. Reduce to field element
    let alpha_bytes = &hash[0..8];  // Take first 64 bits
    let alpha_raw = u64::from_le_bytes(alpha_bytes.try_into().unwrap());
    let alpha = Field::new(alpha_raw % MODULUS);
    
    Challenge { alpha, hash }
}
```

**Security**: 
- SHA3-256 collision resistance â†’ challenge unpredictable
- Uniform distribution over F_q (with negligible bias for 64-bit â†’ q)
- Domain separation: `"LAMBDA-SNARK-R-FS-v1"` prefix

---

## Opening Proof

### Structure

```rust
pub struct Opening {
    /// Evaluation y = f(Î±)
    evaluation: Field,
    
    /// LWE witness for opening
    witness: Vec<u64>,
}
```

### Generation

**Input**:
- `pk: &ProvingKey`
- `f: Polynomial` â€” witness polynomial
- `Î±: Field` â€” challenge point
- `r: Randomness` â€” commitment randomness

**Output**:
- `opening: Opening`

**Algorithm**:
```rust
fn generate_opening(pk: &ProvingKey, f: &Polynomial, alpha: Field, r: &Randomness) 
    -> Result<Opening, Error> 
{
    // 1. Evaluate polynomial
    let evaluation = f.evaluate(alpha);
    
    // 2. Generate LWE opening witness
    let witness = pk.ctx.open_commitment(f, alpha, r)?;
    
    // 3. Return opening
    Ok(Opening { evaluation, witness })
}
```

### Verification (Verifier Side)

```rust
fn verify_opening(vk: &VerifyingKey, commitment: &Commitment, 
                 alpha: Field, opening: &Opening) -> bool 
{
    // Check: commitment opens to (alpha, evaluation)
    vk.ctx.verify_opening(commitment, alpha, opening.evaluation, &opening.witness)
}
```

---

## Proof Size Analysis

### Components

| Component   | Size (bytes) | Notes |
|-------------|--------------|-------|
| Commitment  | ~2KB         | LWE ciphertext (n=4096, k=2, log q=44) |
| Challenge   | 40           | Field element (8 bytes) + hash (32 bytes) |
| Opening     | ~1KB         | Evaluation (8 bytes) + LWE witness (~1KB) |
| **Total**   | **~3KB**     | Post-quantum secure proof |

**Comparison**:
- Groth16 (BN254): ~192 bytes (not post-quantum)
- Plonk (BLS12-381): ~768 bytes (not post-quantum)
- Î›SNARK-R: ~3KB (post-quantum secure)

**Tradeoff**: 5-15x larger proof, but quantum-resistant.

---

## Security Properties

### Soundness

**Claim**: If prover generates accepted proof without valid witness, breaks LWE hardness.

**Sketch**:
1. Proof acceptance â†’ opening verification passes
2. Opening verification â†’ commitment binds to f(Î±) = y
3. Fiat-Shamir â†’ Î± unpredictable before commitment
4. Forged proof â†’ find f' â‰  f with same commitment (breaks LWE binding)

**Reduction**: Soundness â‰¤ LWE hardness + SHA3 collision resistance

---

### Zero-Knowledge

**Claim**: Proof reveals nothing beyond statement validity.

**Sketch**:
1. Commitment is LWE ciphertext â†’ semantic security
2. Challenge is public coin (Fiat-Shamir)
3. Opening reveals only f(Î±) at random Î±
4. Simulator: sample random f, commit, derive Î±, adjust opening

**Note**: Full ZK requires additional blinding (not implemented in basic version).

---

### Succinctness

**Proof Size**: O(Î» log n) where Î» = security parameter, n = witness size

**Verification Time**: O(m + log n) where m = # constraints

**Prover Time**: O(n log n) for polynomial operations + O(m) for R1CS validation

---

## Error Handling

### Prover Errors

```rust
pub enum ProverError {
    /// Witness length mismatch
    WitnessLengthMismatch { expected: usize, got: usize },
    
    /// Witness doesn't satisfy R1CS
    InvalidWitness,
    
    /// Public inputs mismatch
    PublicInputMismatch,
    
    /// Witness first element is not 1
    InvalidConstant,
    
    /// FFI error
    FfiError(String),
}
```

### Handling Strategy

```rust
impl Prover {
    pub fn prove(&self, witness: &[u64], public_inputs: &[u64]) 
        -> Result<Proof, ProverError> 
    {
        // Validate inputs
        self.validate_inputs(witness, public_inputs)?;
        
        // Validate witness satisfies R1CS
        if !self.r1cs.validate_witness(witness)? {
            return Err(ProverError::InvalidWitness);
        }
        
        // Generate proof (cannot fail if inputs valid)
        self.prove_internal(witness, public_inputs)
    }
}
```

---

## Testing Strategy

### Unit Tests

1. **Polynomial Encoding**
   - `test_witness_to_polynomial`: [1,7,13,91] â†’ f(X) = 1+7X+13XÂ²+91XÂ³
   - `test_polynomial_evaluation`: f(Î±) = Î£ z_iÂ·Î±^i
   
2. **Fiat-Shamir**
   - `test_challenge_deterministic`: Same inputs â†’ same challenge
   - `test_challenge_uniform`: Distribution check
   - `test_challenge_collision_resistance`: Different inputs â†’ different challenges

3. **Opening**
   - `test_opening_correctness`: verify_opening(commitment, Î±, opening) = true
   - `test_opening_soundness`: Forged opening rejected

### Integration Tests

1. **TV-1 Multiplication**
   - Witness: [1, 7, 13, 91]
   - Public: [1, 91]
   - Proof generation + verification

2. **TV-2 Plaquette**
   - Witness: [1, 314, 628, 471, 471]
   - Public: [1]
   - Proof generation + verification

3. **Invalid Witness**
   - Corrupted witness â†’ ProverError::InvalidWitness

---

## Implementation Plan (M2.2 Subtasks)

### M2.2.2: Polynomial Commitment
- File: `rust-api/lambda-snark/src/polynomial.rs`
- Implement: `Polynomial`, `encode_witness`, `evaluate`
- Tests: encoding correctness, evaluation

### M2.2.3: Fiat-Shamir Challenge
- File: `rust-api/lambda-snark/src/challenge.rs`
- Implement: `derive_challenge`
- Tests: determinism, collision resistance

### M2.2.4: Opening Proofs
- File: `rust-api/lambda-snark/src/opening.rs`
- Implement: `generate_opening`, `verify_opening`
- Tests: correctness, soundness

### M2.2.5: Proof Serialization
- Update: `rust-api/lambda-snark/src/lib.rs`
- Implement: `Serialize/Deserialize` for `Proof`
- Tests: roundtrip, size check

### M2.2.6: Integration
- File: `rust-api/lambda-snark/tests/prover.rs`
- Tests: TV-1, TV-2, invalid witness
- Benchmarks: proof time, size

---

## Next Steps

1. âœ… Design Prover API (this document)
2. ğŸ”„ Implement polynomial encoding (M2.2.2)
3. ğŸ”„ Implement Fiat-Shamir (M2.2.3)
4. ğŸ”„ Implement opening proofs (M2.2.4)
5. ğŸ”„ Add serialization (M2.2.5)
6. ğŸ”„ Integration tests (M2.2.6)
7. ğŸ”„ Documentation and commit (M2.2.7)

---

**Status**: ğŸ“‹ API design complete, ready for implementation

