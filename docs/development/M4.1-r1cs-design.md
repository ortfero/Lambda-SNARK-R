# M4.1: R1CS Design Specification

**Date**: November 7, 2025  
**Status**: DRAFT  
**Author**: URPKS Senior Engineer  
**Milestone**: M4.1 R1CS Integration Design

---

## Executive Summary

This document specifies the design for full R1CS (Rank-1 Constraint System) integration into ŒõSNARK-R, enabling proving/verification of arbitrary arithmetic circuits. The design extends the existing polynomial-based prover (M2.2/M2.3) and zero-knowledge system (M3) to support constraint satisfaction proofs.

**Key Design Decisions**:
- **Sparse matrix representation** for A, B, C (typical circuits are <1% dense)
- **Witness-to-polynomial encoding** via coefficient injection (z_i ‚Üí f(X) coefficient)
- **Constraint polynomial** Q(X) = (Az(X) ‚äô Bz(X) - Cz(X)) / Z_H(X) for batch verification
- **Zero-knowledge extension** via polynomial blinding (compatible with M3)
- **Backward compatibility** preserve prove_simple/verify_simple for non-R1CS use cases

**Security Properties**:
- Soundness: Œµ ‚â§ 1/q + Adv_LWE ‚âà 2^-44 (preserved from M2.3)
- Zero-Knowledge: Adv_ZK ‚â§ 2^-128 (inherited from M3)
- Completeness: 100% for valid witnesses satisfying constraints

---

## [Œ£] Formal R1CS Definition

### 1.1 R1CS Structure

A **Rank-1 Constraint System** over field F_q consists of:

```
R1CS = (m, n, l, A, B, C, public_inputs)

Where:
  m = number of constraints
  n = total witness size (including public inputs)
  l = number of public inputs (1-indexed: z_1, ..., z_l)
  A, B, C ‚àà F_q^{m√ón} = constraint matrices (sparse)
  public_inputs = [z_1, ..., z_l] ‚àà F_q^l
```

**Witness** z ‚àà F_q^n satisfies R1CS if:

```
‚àÄ i ‚àà [m]:  (Az)_i ¬∑ (Bz)_i = (Cz)_i

Equivalently in matrix form:
  (Az) ‚äô (Bz) = Cz

Where ‚äô denotes element-wise (Hadamard) product
```

**Example** (multiplication gate: a ¬∑ b = c):

```
Witness: z = [1, a, b, c]  (z_1=1 is constant)

Constraint: a ¬∑ b = c
A = [0, 1, 0, 0]  (select z_2 = a)
B = [0, 0, 1, 0]  (select z_3 = b)
C = [0, 0, 0, 1]  (select z_4 = c)

Check: (Az) ¬∑ (Bz) = a ¬∑ b = c = (Cz) ‚úì
```

### 1.2 Witness Encoding as Polynomial

Current system (M2.2) encodes witness as polynomial:

```rust
f(X) = Œ£_{i=0}^{n-1} z_i ¬∑ X^i
```

For R1CS, we extend this to constraint polynomials:

```
A(X, Y) = Œ£_{i‚àà[m], j‚àà[n]} A_{i,j} ¬∑ L_i(X) ¬∑ W_j(Y)
B(X, Y) = Œ£_{i‚àà[m], j‚àà[n]} B_{i,j} ¬∑ L_i(X) ¬∑ W_j(Y)
C(X, Y) = Œ£_{i‚àà[m], j‚àà[n]} C_{i,j} ¬∑ L_i(X) ¬∑ W_j(Y)

Where:
  L_i(X) = Lagrange basis for constraints (evaluation domain H_m)
  W_j(Y) = Lagrange basis for witness (evaluation domain H_n)
```

**Simplification** (for ŒõSNARK-R v1): Use **flattened polynomial encoding**:

```
For each constraint i, compute:
  a_i = (Az)_i = Œ£_j A_{i,j} ¬∑ z_j
  b_i = (Bz)_i = Œ£_j B_{i,j} ¬∑ z_j
  c_i = (Cz)_i = Œ£_j C_{i,j} ¬∑ z_j

Encode as polynomials over domain H = {œâ^0, œâ^1, ..., œâ^{m-1}}:
  A_z(X) = Œ£_{i‚àà[m]} a_i ¬∑ L_i(X)
  B_z(X) = Œ£_{i‚àà[m]} b_i ¬∑ L_i(X)
  C_z(X) = Œ£_{i‚àà[m]} c_i ¬∑ L_i(X)

Where L_i(X) = Lagrange polynomial s.t. L_i(œâ^j) = Œ¥_{ij}
```

### 1.3 Constraint Satisfaction Polynomial

Define the **quotient polynomial** Q(X):

```
Q(X) = (A_z(X) ¬∑ B_z(X) - C_z(X)) / Z_H(X)

Where:
  Z_H(X) = Œ†_{i‚àà[m]} (X - œâ^i) = X^m - 1  (vanishing polynomial)
```

**Key Property**: Witness satisfies R1CS ‚ü∫ Q(X) is a polynomial (no remainder)

Proof:
```
A_z(œâ^i) ¬∑ B_z(œâ^i) = C_z(œâ^i)  for all i ‚àà [m]
‚ü∫ A_z(X) ¬∑ B_z(X) - C_z(X) vanishes on H
‚ü∫ Z_H(X) | (A_z(X) ¬∑ B_z(X) - C_z(X))
‚ü∫ Q(X) ‚àà F_q[X]
```

---

## [Œì] Security Gates & Invariants

### 2.1 Soundness Preservation

**Gate**: Soundness error must remain Œµ ‚â§ 2^-44

**Analysis**:

Current system (M2.2/M2.3):
```
Prover commits to f(X), verifier checks f(Œ±) at random Œ±
Soundness: Pr[cheat accepted] ‚â§ deg(f)/q + Adv_LWE
```

R1CS extension:
```
Prover commits to Q(X), verifier checks Q(Œ±)¬∑Z_H(Œ±) = A_z(Œ±)¬∑B_z(Œ±) - C_z(Œ±)
Soundness: Pr[invalid witness passes] ‚â§ (deg(Q) + m)/q + Adv_LWE
```

**Schwartz-Zippel bound**:
```
If witness is invalid, then Q(X) is not a polynomial (has degree > deg or division fails)
Probability random Œ± satisfies check: ‚â§ 2m/q  (worst case: 2 polynomials of degree m)

For q = 2^44 + 1, m ‚â§ 10^6:
  Œµ ‚â§ 2¬∑10^6 / 2^44 + Adv_LWE ‚âà 2^-24 + 2^-128 ‚âà 2^-24
```

**ISSUE**: This exceeds our target Œµ ‚â§ 2^-44 for large m!

**Mitigation Options**:
1. **Increase q**: Use q = 2^64 + prime ‚Üí Œµ ‚âà 2^-44 (but requires larger modulus, performance hit)
2. **Multiple challenges**: Query k random points ‚Üí Œµ ‚âà (2m/q)^k (but k=2 sufficient: (2¬∑10^6/2^44)^2 ‚âà 2^-48)
3. **Structured constraints**: Reduce effective m via constraint batching

**Recommended**: **Option 2** (2 challenge queries, minimal overhead)

### 2.2 Zero-Knowledge Preservation

**Gate**: Adv_ZK ‚â§ 2^-128 (HVZK property from M3)

**Strategy**: Extend polynomial blinding to Q(X):

```
prove_zk_r1cs:
  1. Compute Q(X) from witness z
  2. Generate random blinding polynomial r_Q(X) with deg(r_Q) = deg(Q)
  3. Compute Q'(X) = Q(X) + r_Q(X)
  4. Commit to Q'(X) using LWE
  5. Derive challenge Œ± via Fiat-Shamir
  6. Open Q'(Œ±)

Simulator (without witness):
  1. Sample random Q'(X) ~ U(F_q^{deg+1})
  2. Commit to Q'(X)
  3. Derive challenge Œ±
  4. Open Q'(Œ±)
```

**Indistinguishability**:
```
Real: Q(X) + r_Q(X) where r_Q ~ U(F_q^{deg+1})
Sim:  Q'(X)          where Q' ~ U(F_q^{deg+1})

Distributions are identical (one-time pad) ‚Üí Adv_ZK ‚â§ Adv_LWE ‚âà 2^-128 ‚úì
```

### 2.3 Completeness

**Gate**: Valid witness always produces valid proof

**Proof Sketch**:
```
Given: z ‚àà F_q^n satisfies (Az) ‚äô (Bz) = Cz

1. Compute a_i, b_i, c_i for all i ‚àà [m]
2. Interpolate A_z(X), B_z(X), C_z(X)
3. Compute Q(X) = (A_z(X)¬∑B_z(X) - C_z(X)) / Z_H(X)
   - By assumption, A_z(œâ^i)¬∑B_z(œâ^i) = C_z(œâ^i) for all i
   - Therefore Z_H(X) divides numerator ‚Üí Q(X) is polynomial ‚úì
4. Commit to Q(X), derive Œ±, open Q(Œ±)
5. Verifier checks: Q(Œ±)¬∑Z_H(Œ±) = A_z(Œ±)¬∑B_z(Œ±) - C_z(Œ±)
   - This is polynomial identity, holds for all Œ± ‚úì

Therefore: Valid witness ‚Üí Valid proof (completeness = 100%)
```

### 2.4 Backward Compatibility

**Gate**: Existing prove_simple/verify_simple must remain functional

**Strategy**:
- prove_simple: Direct witness‚Üípolynomial encoding (unchanged)
- prove_r1cs: New API for R1CS instances
- verify_simple: Works with both (proof format identical)
- verify_r1cs: Validates constraint satisfaction

**API Separation**:
```rust
// Existing (M2.2/M2.3)
prove_simple(witness: &[u64], ...) -> Proof  // Direct polynomial
verify_simple(proof: &Proof, ...) -> bool    // Direct verification

// New (M4.2)
prove_r1cs(r1cs: &R1CS, witness: &[u64], ...) -> Proof
verify_r1cs(r1cs: &R1CS, proof: &Proof, ...) -> bool
```

---

## [ùí´] Design Options

### 3.1 Matrix Representation

**Option A**: Dense matrices (Vec<Vec<u64>>)
- **Pros**: Simple, direct indexing
- **Cons**: Memory O(m¬∑n), impractical for large circuits
- **Use case**: Toy examples, testing

**Option B**: Sparse matrices (HashMap<(usize, usize), u64>)
- **Pros**: Memory O(nnz), typical circuits have nnz ‚âà 0.01¬∑m¬∑n
- **Cons**: Slower access, hash overhead
- **Use case**: General circuits

**Option C**: CSR (Compressed Sparse Row) format
- **Pros**: Minimal memory, cache-friendly iteration
- **Cons**: Complex construction, immutable after build
- **Use case**: Production (after R1CS construction)

**Recommended**: **Option B for construction ‚Üí Option C for proving**

Rationale:
- HashMap during circuit building (mutations needed)
- Convert to CSR before proving (optimize memory + iteration)
- Typical circuit: m=10^6, n=10^5, nnz=10^7 ‚Üí 80 MB (CSR) vs 800 GB (dense)

### 3.2 Polynomial Encoding Strategy

**Option A**: Direct coefficient encoding (current M2.2)
```rust
f(X) = Œ£ z_i ¬∑ X^i
```
- **Pros**: Simple, no interpolation needed
- **Cons**: Doesn't support constraint structure
- **Verdict**: Insufficient for R1CS

**Option B**: Lagrange interpolation over H_m
```rust
A_z(X) = Œ£ a_i ¬∑ L_i(X)
L_i(X) = Œ†_{j‚â†i} (X - œâ^j) / (œâ^i - œâ^j)
```
- **Pros**: Natural for constraint polynomials, standard in PLONK/Groth16
- **Cons**: O(m^2) interpolation cost (na√Øve), requires FFT domain
- **Optimization**: Use NTT (Fast Fourier Transform) ‚Üí O(m log m)
- **Verdict**: **RECOMMENDED** (with NTT)

**Option C**: Multi-linear polynomials (HyperPlonk style)
```rust
f(x_1, ..., x_k) where m = 2^k
```
- **Pros**: Logarithmic proof size, better asymptotics
- **Cons**: Requires PCS changes, major overhaul
- **Verdict**: Future work (M5+ optimization)

**Selected**: **Option B (Lagrange + NTT)**

### 3.3 Challenge Strategy (Soundness Amplification)

**Option A**: Single challenge Œ±
- Soundness: Œµ ‚âà 2m/q ‚âà 2^-24 (insufficient for m=10^6, q=2^44)

**Option B**: Two challenges Œ±, Œ≤
```
Check 1: Q(Œ±)¬∑Z_H(Œ±) = A_z(Œ±)¬∑B_z(Œ±) - C_z(Œ±)
Check 2: Q(Œ≤)¬∑Z_H(Œ≤) = A_z(Œ≤)¬∑B_z(Œ≤) - C_z(Œ≤)

Soundness: Œµ ‚âà (2m/q)^2 ‚âà 2^-48 ‚úì
```

**Option C**: Increase modulus q ‚Üí 2^64 + prime
- Soundness: Œµ ‚âà 2m/q ‚âà 2¬∑10^6/2^64 ‚âà 2^-44 ‚úì
- **Cons**: Larger field, slower arithmetic

**Recommended**: **Option B (two challenges)**

Rationale:
- Minimal overhead (1 extra evaluation + opening)
- Preserves modulus q = 2^44 + 1 (optimized for SEAL)
- Soundness: Œµ ‚â§ (2¬∑10^6/2^44)^2 ‚âà 2^-48 < 2^-44 ‚úì

---

## [Œõ] Trade-off Analysis

### 4.1 Memory Consumption

| Component | Dense | Sparse (HashMap) | CSR | Notes |
|-----------|-------|------------------|-----|-------|
| Matrices A,B,C | O(m¬∑n) | O(nnz) | O(nnz) | nnz ‚âà 0.01¬∑m¬∑n typical |
| Witness z | O(n) | O(n) | O(n) | Required regardless |
| Polynomials A_z, B_z, C_z | O(m) | O(m) | O(m) | After matrix-vector product |
| Quotient Q(X) | O(m) | O(m) | O(m) | Constraint polynomial |
| **Total** | **O(m¬∑n)** | **O(nnz + m + n)** | **O(nnz + m)** | CSR most efficient |

**Example** (m=10^6, n=10^5, nnz=10^7):
- Dense: 3 matrices √ó 10^6 √ó 10^5 √ó 8 bytes = **2.4 TB** ‚ùå
- Sparse: 3 √ó 10^7 √ó (16 bytes key + 8 bytes value) = **720 MB** ‚úì
- CSR: 3 √ó (10^7 √ó 8 + 10^6 √ó 8) = **264 MB** ‚úì

### 4.2 Computation Cost

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Matrix construction | O(nnz) | Circuit ‚Üí sparse matrices |
| Matrix-vector product | O(nnz) | Compute Az, Bz, Cz |
| Lagrange interpolation | O(m log m) | NTT-based (requires FFT domain) |
| Polynomial division | O(m log m) | Q(X) = (A_z¬∑B_z - C_z)/Z_H |
| Polynomial evaluation | O(m) | Evaluate at challenge points |
| LWE commitment | O(m) | Commit to Q(X) coefficients |
| **Total prover** | **O(nnz + m log m)** | Dominated by NTT |

**Benchmark estimate** (m=10^6):
- Matrix ops: 10^7 √ó 10 ns = **100 ms**
- NTT: 10^6 √ó log_2(10^6) √ó 50 ns ‚âà **1 sec**
- Polynomial ops: 10^6 √ó 20 ns = **20 ms**
- LWE commitment: ~7 ms (from M2.2)
- **Total**: ~**1.2 sec** (acceptable for v1)

### 4.3 Verification Cost

| Check | Complexity | Cost |
|-------|------------|------|
| Recompute public A_pub, B_pub, C_pub | O(l ¬∑ nnz_pub) | ~1 ms (l small) |
| Evaluate Z_H(Œ±), Z_H(Œ≤) | O(1) | Precompute œâ^m - 1 |
| Check Q(Œ±)¬∑Z_H(Œ±) = A_z(Œ±)¬∑B_z(Œ±) - C_z(Œ±) | O(1) | Field ops |
| Check Q(Œ≤)¬∑Z_H(Œ≤) = A_z(Œ≤)¬∑B_z(Œ≤) - C_z(Œ≤) | O(1) | Second challenge |
| LWE opening verification | O(1) | From M2.3 |
| **Total verifier** | **O(l)** | ~**1-2 ms** ‚úì |

**Success criteria**: Verifier <1ms per proof ‚Üí achievable with l ‚â§ 100 public inputs

### 4.4 Proof Size

| Component | Size | Notes |
|-----------|------|-------|
| LWE commitment | ~1 KB | SEAL ciphertext |
| Challenge Œ± | 8 bytes | Field element |
| Challenge Œ≤ | 8 bytes | Second challenge |
| Opening Q(Œ±) | 8 bytes | Field element |
| Opening Q(Œ≤) | 8 bytes | Field element |
| Opening metadata | ~100 bytes | SEAL opening proof |
| **Total** | **~1.2 KB** | Meets <50 KB target ‚úì |

---

## [R] Implementation Specification

### 5.1 Data Structures

```rust
/// Sparse matrix in CSR (Compressed Sparse Row) format
#[derive(Debug, Clone)]
pub struct SparseMatrix {
    rows: usize,           // m (number of constraints)
    cols: usize,           // n (witness size)
    row_ptr: Vec<usize>,   // row_ptr[i] = index in col_indices where row i starts
    col_indices: Vec<usize>, // Column indices of non-zero entries
    values: Vec<u64>,      // Non-zero values (field elements)
}

impl SparseMatrix {
    /// Matrix-vector product: result[i] = Œ£_j M[i,j] * v[j]
    pub fn mul_vec(&self, v: &[u64], modulus: u64) -> Vec<u64>;
    
    /// Get element at (row, col)
    pub fn get(&self, row: usize, col: usize) -> u64;
    
    /// Number of non-zero entries
    pub fn nnz(&self) -> usize { self.values.len() }
}

/// R1CS instance
#[derive(Debug, Clone)]
pub struct R1CS {
    /// Number of constraints
    pub m: usize,
    
    /// Total witness size (including public inputs)
    pub n: usize,
    
    /// Number of public inputs (z_1, ..., z_l)
    pub l: usize,
    
    /// Constraint matrices (sparse CSR format)
    pub a: SparseMatrix,
    pub b: SparseMatrix,
    pub c: SparseMatrix,
    
    /// Field modulus
    pub modulus: u64,
    
    /// Evaluation domain size (power of 2, ‚â• m for NTT)
    pub domain_size: usize,
    
    /// Root of unity œâ for NTT domain
    pub omega: u64,
}

impl R1CS {
    /// Check if witness satisfies constraints: (Az) ‚äô (Bz) = Cz
    pub fn is_satisfied(&self, witness: &[u64]) -> bool;
    
    /// Compute constraint polynomials A_z(X), B_z(X), C_z(X)
    /// Returns coefficients in evaluation form (NTT domain)
    pub fn compute_constraint_polys(&self, witness: &[u64]) 
        -> (Vec<u64>, Vec<u64>, Vec<u64>);
    
    /// Compute quotient polynomial Q(X) = (A_z¬∑B_z - C_z) / Z_H
    pub fn compute_quotient_poly(&self, witness: &[u64]) 
        -> Result<Vec<u64>, Error>;
}

/// Circuit builder for constructing R1CS
#[derive(Debug)]
pub struct CircuitBuilder {
    constraints: Vec<(Vec<(usize, u64)>, Vec<(usize, u64)>, Vec<(usize, u64)>)>,
    num_vars: usize,
    num_public: usize,
    modulus: u64,
}

impl CircuitBuilder {
    pub fn new(modulus: u64) -> Self;
    
    /// Allocate new variable, returns index
    pub fn alloc_var(&mut self) -> usize;
    
    /// Mark first l variables as public inputs
    pub fn set_public_inputs(&mut self, l: usize);
    
    /// Add constraint: (Œ£ a_j¬∑z_j) ¬∑ (Œ£ b_j¬∑z_j) = (Œ£ c_j¬∑z_j)
    pub fn add_constraint(
        &mut self,
        a: Vec<(usize, u64)>,  // [(var_index, coeff), ...]
        b: Vec<(usize, u64)>,
        c: Vec<(usize, u64)>,
    );
    
    /// Build final R1CS (converts to sparse matrices)
    pub fn build(self) -> R1CS;
}
```

### 5.2 Prover Algorithm

```rust
/// Prove R1CS instance with witness
pub fn prove_r1cs(
    r1cs: &R1CS,
    witness: &[u64],
    ctx: &LweContext,
    commit_seed: u64,
) -> Result<ProofR1CS, Error> {
    // 1. Validate witness
    if witness.len() != r1cs.n {
        return Err(Error::Ffi("Witness size mismatch".to_string()));
    }
    if !r1cs.is_satisfied(witness) {
        return Err(Error::Ffi("Witness does not satisfy R1CS".to_string()));
    }
    
    // 2. Compute quotient polynomial Q(X)
    let q_coeffs = r1cs.compute_quotient_poly(witness)?;
    
    // 3. Commit to Q(X)
    let commitment_q = Commitment::new(ctx, &q_coeffs, commit_seed)?;
    
    // 4. Compute public constraint values (for verifier)
    let public_inputs = &witness[0..r1cs.l];
    let (a_pub, b_pub, c_pub) = r1cs.compute_public_constraint_values(public_inputs);
    
    // 5. Derive Fiat-Shamir challenges Œ±, Œ≤
    let challenge_alpha = Challenge::derive(public_inputs, &commitment_q, r1cs.modulus);
    let challenge_beta = Challenge::derive_second(&challenge_alpha, &commitment_q, r1cs.modulus);
    
    // 6. Evaluate polynomials at challenge points
    let (a_z_poly, b_z_poly, c_z_poly) = r1cs.compute_constraint_polys(witness);
    
    let q_alpha = poly_eval(&q_coeffs, challenge_alpha.value(), r1cs.modulus);
    let q_beta = poly_eval(&q_coeffs, challenge_beta.value(), r1cs.modulus);
    
    let a_z_alpha = poly_eval(&a_z_poly, challenge_alpha.value(), r1cs.modulus);
    let b_z_alpha = poly_eval(&b_z_poly, challenge_alpha.value(), r1cs.modulus);
    let c_z_alpha = poly_eval(&c_z_poly, challenge_alpha.value(), r1cs.modulus);
    
    let a_z_beta = poly_eval(&a_z_poly, challenge_beta.value(), r1cs.modulus);
    let b_z_beta = poly_eval(&b_z_poly, challenge_beta.value(), r1cs.modulus);
    let c_z_beta = poly_eval(&c_z_poly, challenge_beta.value(), r1cs.modulus);
    
    // 7. Generate opening proofs
    let opening_alpha = generate_opening_r1cs(
        &commitment_q, 
        challenge_alpha.value(),
        q_alpha,
        commit_seed,
    );
    
    let opening_beta = generate_opening_r1cs(
        &commitment_q,
        challenge_beta.value(),
        q_beta,
        commit_seed,
    );
    
    // 8. Assemble proof
    Ok(ProofR1CS {
        commitment: commitment_q,
        challenge_alpha,
        challenge_beta,
        q_alpha,
        q_beta,
        a_z_alpha,
        b_z_alpha,
        c_z_alpha,
        a_z_beta,
        b_z_beta,
        c_z_beta,
        opening_alpha,
        opening_beta,
    })
}
```

### 5.3 Verifier Algorithm

```rust
/// Verify R1CS proof
pub fn verify_r1cs(
    r1cs: &R1CS,
    public_inputs: &[u64],
    proof: &ProofR1CS,
) -> bool {
    // 1. Validate public inputs
    if public_inputs.len() != r1cs.l {
        return false;
    }
    
    // 2. Recompute Fiat-Shamir challenges
    let challenge_alpha_recomputed = Challenge::derive(
        public_inputs,
        &proof.commitment,
        r1cs.modulus,
    );
    
    let challenge_beta_recomputed = Challenge::derive_second(
        &challenge_alpha_recomputed,
        &proof.commitment,
        r1cs.modulus,
    );
    
    // 3. Check challenge consistency
    if proof.challenge_alpha != challenge_alpha_recomputed {
        return false;
    }
    if proof.challenge_beta != challenge_beta_recomputed {
        return false;
    }
    
    // 4. Evaluate vanishing polynomial Z_H(Œ±) = Œ±^m - 1
    let alpha = proof.challenge_alpha.value();
    let beta = proof.challenge_beta.value();
    
    let z_h_alpha = mod_pow(alpha, r1cs.m as u64, r1cs.modulus)
        .wrapping_sub(1) % r1cs.modulus;
    
    let z_h_beta = mod_pow(beta, r1cs.m as u64, r1cs.modulus)
        .wrapping_sub(1) % r1cs.modulus;
    
    // 5. Check constraint equation at Œ±:
    //    Q(Œ±) ¬∑ Z_H(Œ±) = A_z(Œ±) ¬∑ B_z(Œ±) - C_z(Œ±)
    let lhs_alpha = (proof.q_alpha * z_h_alpha) % r1cs.modulus;
    let rhs_alpha = (proof.a_z_alpha * proof.b_z_alpha) % r1cs.modulus;
    let rhs_alpha = (rhs_alpha + r1cs.modulus - proof.c_z_alpha) % r1cs.modulus;
    
    if lhs_alpha != rhs_alpha {
        return false;
    }
    
    // 6. Check constraint equation at Œ≤ (soundness amplification)
    let lhs_beta = (proof.q_beta * z_h_beta) % r1cs.modulus;
    let rhs_beta = (proof.a_z_beta * proof.b_z_beta) % r1cs.modulus;
    let rhs_beta = (rhs_beta + r1cs.modulus - proof.c_z_beta) % r1cs.modulus;
    
    if lhs_beta != rhs_beta {
        return false;
    }
    
    // 7. Verify LWE opening proofs
    if !verify_opening(
        &proof.commitment,
        proof.challenge_alpha.alpha(),
        &proof.opening_alpha,
        r1cs.modulus,
    ) {
        return false;
    }
    
    if !verify_opening(
        &proof.commitment,
        proof.challenge_beta.alpha(),
        &proof.opening_beta,
        r1cs.modulus,
    ) {
        return false;
    }
    
    true
}
```

### 5.4 Zero-Knowledge Extension

```rust
/// Prove R1CS instance with zero-knowledge
pub fn prove_r1cs_zk(
    r1cs: &R1CS,
    witness: &[u64],
    ctx: &LweContext,
    commit_seed: u64,
    blinding_seed: Option<u64>,
) -> Result<ProofR1CS, Error> {
    // Steps 1-2: Same as prove_r1cs
    let q_coeffs = r1cs.compute_quotient_poly(witness)?;
    
    // 3. Generate random blinding polynomial
    let r_q = Polynomial::random_blinding(q_coeffs.len() - 1, r1cs.modulus, blinding_seed);
    
    // 4. Compute blinded quotient Q'(X) = Q(X) + r_Q(X)
    let q_poly = Polynomial::new(q_coeffs, r1cs.modulus);
    let q_blinded = q_poly.add(&r_q);
    
    // 5. Commit to blinded polynomial
    let commitment_q = Commitment::new(ctx, q_blinded.coefficients(), commit_seed)?;
    
    // 6-8: Same as prove_r1cs (but using q_blinded instead of q)
    // ...
}

/// Simulate R1CS proof without witness (for ZK validation)
pub fn simulate_r1cs_proof(
    r1cs: &R1CS,
    public_inputs: &[u64],
    ctx: &LweContext,
    commit_seed: u64,
    sim_seed: Option<u64>,
) -> Result<ProofR1CS, Error> {
    // 1. Sample random quotient polynomial (simulates blinded Q)
    let degree = r1cs.domain_size - 1;
    let q_prime = Polynomial::random_blinding(degree, r1cs.modulus, sim_seed);
    
    // 2. Commit to random polynomial
    let commitment_q = Commitment::new(ctx, q_prime.coefficients(), commit_seed)?;
    
    // 3-8: Same challenge derivation and opening as real prover
    // (proof structure identical, but values are random)
    // ...
}
```

### 5.5 Circuit Builder Example

```rust
// Example: Prove a * b = c (multiplication gate)
let modulus = 17592186044417;  // 2^44 + 1

let mut builder = CircuitBuilder::new(modulus);

// Variables: z_0=1 (constant), z_1=a, z_2=b, z_3=c
let one = builder.alloc_var();   // z_0 = 1
let a = builder.alloc_var();     // z_1 = a
let b = builder.alloc_var();     // z_2 = b
let c = builder.alloc_var();     // z_3 = c

// Public inputs: z_0, z_3 (constant and result)
builder.set_public_inputs(2);

// Constraint: a * b = c
// A = [0, 1, 0, 0] (select a)
// B = [0, 0, 1, 0] (select b)
// C = [0, 0, 0, 1] (select c)
builder.add_constraint(
    vec![(a, 1)],  // A: 1¬∑a
    vec![(b, 1)],  // B: 1¬∑b
    vec![(c, 1)],  // C: 1¬∑c
);

let r1cs = builder.build();

// Witness: [1, 7, 13, 91]
let witness = vec![1, 7, 13, 91];

// Prove
let proof = prove_r1cs(&r1cs, &witness, &ctx, 0x1234)?;

// Verify
let valid = verify_r1cs(&r1cs, &[1, 91], &proof);
assert!(valid);
```

---

## 5.6 Implementation Plan

### Phase 1: Core Data Structures (Week 1)
- [ ] Implement `SparseMatrix` (CSR format)
- [ ] Implement `R1CS` struct
- [ ] Add constraint satisfaction check `is_satisfied()`
- [ ] Unit tests for matrix operations

### Phase 2: Circuit Builder (Week 1-2)
- [ ] Implement `CircuitBuilder` API
- [ ] Add constraint addition and variable allocation
- [ ] Convert builder to R1CS (sparse matrices)
- [ ] Example circuits (multiplication, addition)

### Phase 3: Polynomial Computation (Week 2)
- [ ] Implement Lagrange interpolation (NTT-based)
- [ ] Compute constraint polynomials A_z, B_z, C_z
- [ ] Compute quotient polynomial Q(X)
- [ ] Polynomial division by Z_H(X)

### Phase 4: Prover (Week 2-3)
- [ ] Implement `prove_r1cs()`
- [ ] Add two-challenge soundness amplification
- [ ] Integrate with LWE commitment (reuse M2.2)
- [ ] Integration tests with example circuits

### Phase 5: Verifier (Week 3)
- [ ] Implement `verify_r1cs()`
- [ ] Add two-challenge verification
- [ ] Reuse opening verification from M2.3
- [ ] Soundness tests (invalid witness rejection)

### Phase 6: Zero-Knowledge (Week 3-4)
- [ ] Extend `prove_r1cs_zk()` with polynomial blinding
- [ ] Implement `simulate_r1cs_proof()`
- [ ] Distinguisher tests (validate ZK property)
- [ ] Performance benchmarks

### Phase 7: Documentation & Examples (Week 4)
- [ ] API documentation (rustdoc)
- [ ] Tutorial: building circuits
- [ ] Example: Sudoku solver as R1CS
- [ ] Performance report

---

## 6. Security Analysis Summary

| Property | Bound | Validation |
|----------|-------|------------|
| **Soundness** | Œµ ‚â§ (2m/q)^2 ‚âà 2^-48 | Two-challenge amplification ‚úì |
| **Zero-Knowledge** | Adv_ZK ‚â§ 2^-128 | Polynomial blinding (M3) ‚úì |
| **Completeness** | 100% | Polynomial identity ‚úì |
| **Verifier Complexity** | O(l) | <1ms for l ‚â§ 100 ‚úì |
| **Proof Size** | ~1.2 KB | Two openings + metadata ‚úì |
| **Prover Time** | O(nnz + m log m) | ~1.2 sec for m=10^6 ‚úì |

---

## 7. Open Questions & Future Work

### 7.1 NTT Domain Selection
- **Q**: How to choose domain size for NTT? Must be power of 2, ‚â• m
- **A**: Round m up to next power of 2, ensure root of unity exists in F_q

### 7.2 Batch Verification
- **Q**: Can we verify multiple R1CS proofs in batch?
- **A**: Yes, via random linear combination (M5.1 optimization)

### 7.3 Recursive Composition
- **Q**: Can we prove R1CS of R1CS (SNARK-of-SNARK)?
- **A**: Future work (requires cycle of curves or IVC, M7+)

### 7.4 Custom Gates
- **Q**: Support non-R1CS gates (e.g., range checks, hash functions)?
- **A**: M4.3 circuit compiler can emit R1CS, or add Plonkish custom gates (M5+)

---

## 8. References

1. **R1CS Definition**: Groth16 paper (https://eprint.iacr.org/2016/260)
2. **Polynomial Commitments**: Marlin (https://eprint.iacr.org/2019/1047)
3. **Zero-Knowledge**: HVZK construction from M3 design
4. **NTT Optimization**: Fast Fourier Transform over finite fields
5. **Sparse Matrices**: CSR format (scipy.sparse documentation)

---

## Appendix A: Test Vectors

### TV-R1CS-1: Multiplication Gate
```
Circuit: a * b = c
Witness: z = [1, 7, 13, 91]
Public: [1, 91]

R1CS:
  m = 1, n = 4, l = 2
  A = [[0, 1, 0, 0]]
  B = [[0, 0, 1, 0]]
  C = [[0, 0, 0, 1]]

Check: (Az)_1 * (Bz)_1 = 7 * 13 = 91 = (Cz)_1 ‚úì
```

### TV-R1CS-2: Two Multiplications
```
Circuit: 
  a * b = c
  c * d = e

Witness: z = [1, 2, 3, 6, 4, 24]
Public: [1, 24]

R1CS:
  m = 2, n = 6, l = 2
  A = [[0, 1, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0]]
  B = [[0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 1, 0]]
  C = [[0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 1]]

Check:
  (Az)_1 * (Bz)_1 = 2 * 3 = 6 = (Cz)_1 ‚úì
  (Az)_2 * (Bz)_2 = 6 * 4 = 24 = (Cz)_2 ‚úì
```

---

## Changelog

- **2025-11-07**: Initial draft (M4.1 design specification)

---

**Status**: READY FOR REVIEW  
**Next**: M4.2 Implementation (R1CS constraint system in Rust)
